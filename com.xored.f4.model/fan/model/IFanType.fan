//
// Copyright (c) 2010 xored software, Inc.
// Licensed under Eclipse Public License version 1.0
//
// History:
//   Ivan Inozemtsev May 12, 2010 - Initial Contribution
//

const mixin IFanType : DltkModelElement
{
  **
  ** Parent pod which defines this type.  For parameterized types derived
  ** from List, Map, or Func, this method always returns the sys pod.
  **
  abstract Str pod()
  
  **
  ** Simple name of the type such as "Str".  For parameterized types derived
  ** from List, Map, or Func, this method always returns "List", "Map",
  ** or "Func" respectively.
  **
  abstract Str name()
  
  **
  ** Qualified name formatted as "pod::name".  For parameterized
  ** types derived from List, Map, or Func, this method always returns
  ** "sys::List", "sys::Map", or "sys::Func" respectively.  If this
  ** a nullable type, the qname does *not* include the "?".
  **
  abstract Str qname()
  
//////////////////////////////////////////////////////////////////////////
// Inheritance
//////////////////////////////////////////////////////////////////////////
  
  **
  ** Return a recursive flattened list of all the types this type
  ** inherits from.  The result list always includes this type itself.
  ** The result of this method represents the complete list of types
  ** implemented by this type - instances of this type are assignable
  ** to any type in this list.  All types (including mixins) will
  ** include sys::Obj in this list.
  **
  abstract Str[] inheritance()
  
//////////////////////////////////////////////////////////////////////////
// Flags
//////////////////////////////////////////////////////////////////////////

  **
  ** Return if this Type is abstract and cannot be instantiated.  This
  ** method will always return true if the type is a mixin.
  **
  abstract Bool isAbstract()

  **
  ** Return if this Type is a class (as opposed to enum or mixin)
  **
  abstract Bool isClass()

  **
  ** Return if this is a const class which means instances of this
  ** class are immutable.
  **
  abstract Bool isConst()

  **
  ** Return if this Type is an Enum type.
  **
  abstract Bool isEnum()

  **
  ** Return if this Type is marked final which means it may not be subclassed.
  **
  abstract Bool isFinal()

  **
  ** Return if this Type has internal protection scope.
  **
  abstract Bool isInternal()

  **
  ** Return if this Type is a mixin type and cannot be instantiated.
  **
  abstract Bool isMixin()

  **
  ** Return if this Type has public protection scope.
  **
  abstract Bool isPublic()

  **
  ** Return if this Type was generated by the compiler.
  **
  abstract Bool isSynthetic()

 //////////////////////////////////////////////////////////////////////////
// Generics
//////////////////////////////////////////////////////////////////////////

  **
  ** Returns a list of type parameters if type is generic, empty list otherwise.
  **
  abstract Str[] params()

  **
  ** Returns new type which is copy of current type with parameters set according
  ** to 'parametrization' map.
  **
  abstract IFanType parameterize(Str:IFanType parametrization)

  **
  ** Returns a map from parameter names to types if type is parametrized, otherwise
  ** an empty map.
  **
  abstract Str:IFanType parametrization()

  **
  ** Returns a list of type parameters which are not set.
  ** 
  Str[] unsetParams() { params.exclude { parametrization[it] != null } }

  **
  ** Returns if type is has unset parameters.
  ** 
  Bool isGeneric() { !unsetParams.isEmpty }

  **
  ** Returns special names for parametrized types as 'ValueType[]' for 'List' and
  ** 'KeyType:ValueType' for 'Map'
  ** 
  abstract Str genericQname()

//////////////////////////////////////////////////////////////////////////
// Slots
//////////////////////////////////////////////////////////////////////////
  protected abstract Str:IFanSlot slotsMap()
  **
  ** List of the all defined fields (including inherited fields).
  **
  virtual IFanField[] fields() { slotsMap.vals.findAll { it is IFanField } }

  **
  ** List of the all defined methods (including inherited methods).
  **
  virtual IFanMethod[] methods() { slotsMap.vals.findAll { it is IFanMethod } }

  **
  ** List of the all defined slots, both fields and methods (including
  ** inherited slots).
  **
  virtual IFanSlot[] slots() { slotsMap.vals } 

  **
  ** Lookup a slot by name.  If the slot doesn't exist and checked
  ** is false then return null, otherwise throw UnknownSlotErr.
  **
  virtual IFanSlot? slot(Str name, Bool checked := true)
  {
    slotsMap[name] ?: (checked ? throw UnknownTypeErr() : null)
  }
  
  **
  ** Convenience for (Method)slot(name, checked)
  **
  virtual IFanMethod? method(Str name, Bool checked := true)
  {
    (slot(name, checked) as IFanMethod) ?: (checked ? throw UnknownTypeErr() : null)
  }
  
  **
  ** Convenience for (Field)slot(name, checked)
  **
  virtual IFanField? field(Str name, Bool checked := true)
  {
    (slot(name, checked) as IFanField) ?: (checked ? throw UnknownTypeErr() : null)
  }
  
  ** Find slot in this type or in super types 
  virtual IFanSlot? findSlot(Str name, IFanNamespace ns, Bool checked := true)
  {
    dirty := slot(name, false)
    if(dirty != null) return dirty
    //deep search
    dirty = inheritance.eachWhile |base|
    {
      ns.findType(base)?.findSlot(name,ns,checked)
    }
    return dirty ?: (checked ? throw UnknownSlotErr() : null)
  }
  
  virtual IFanSlot[] allSlots(IFanNamespace ns)
  {
    result := [Str:IFanSlot][:]
    result.setAll(slotsMap)
    inheritance.each 
    {
      superSlots := ns.findType(it)?.allSlots(ns)?.exclude { it.isCtor }
      if(superSlots != null)
        result.setList(superSlots) { it.name }
    }
    return result.vals
  }
}